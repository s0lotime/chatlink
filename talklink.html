<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Talklink - Chatlink Calling</title>
  <link rel="stylesheet" href="//cdn.chatlink.space/css/talklink.css"/>
  <style>
    #remoteVideo {
      display: none; /* Hide remote video until call accepted */
      width: 100%;
      max-width: 600px;
    }
    #localVideo {
      width: 100%;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <div id="incomingCallBanner" style="display:none;">
    ðŸ“ž Incoming Call from <span id="callerId"></span><br />
    <button id="acceptCallBtn">Accept</button>
    <button id="declineCallBtn">Decline</button>
  </div>

  <h1>Talklink</h1>
  <h1 id="idOutput">My ID is ...</h1>
  <video id="localVideo" autoplay playsinline muted></video>
  <video id="remoteVideo" autoplay playsinline></video>
  <br />
  <input id="targetId" placeholder="Target client ID" />
  <button onclick="startCall()">Start Call</button>
  <button style="display: none" id="toggleAudio">Audio (On)</button>
  <button style="display: none" id="toggleVideo">Video (On)</button>
  <canvas id="equalizer"></canvas>
  <h2>
    Welcome to Talklink! Talklink sounds exactly how it is â€” a way to talk to friends in realtime through voice or video. Right now, Talklink works on an ID exchange system. IDs are unique and change on reload of the page. To call someone, ask for their ID through Chatlink rooms or another source. Only two-user calls are allowed currently.
  </h2>

  <script>
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const toggleAudioBtn = document.getElementById("toggleAudio");
    const toggleVideoBtn = document.getElementById("toggleVideo");
    const incomingCallBanner = document.getElementById("incomingCallBanner");
    const callerIdSpan = document.getElementById("callerId");
    const acceptCallBtn = document.getElementById("acceptCallBtn");
    const declineCallBtn = document.getElementById("declineCallBtn");
    const socket = new WebSocket("wss://chatlink.space/messagerouting/call/connection?room=default");

    let localStream;
    let peer;
    let myId;
    let targetId;
    let incomingOffer = null;
    let remoteCandidatesQueue = []; // queue ICE candidates until remote description is set
    let isCallAccepted = false; // caller-side flag
    let isCallAcceptedByCallee = false; // callee-side flag

    async function checkMediaStatus() {
      const status = {
        micPermission: 'unknown',
        camPermission: 'unknown',
        hasAudio: false,
        audioEnabled: false,
        hasVideo: false,
        videoEnabled: false,
        error: null
      };

      try {
        const micPerm = await navigator.permissions.query({ name: 'microphone' });
        const camPerm = await navigator.permissions.query({ name: 'camera' });

        status.micPermission = micPerm.state;
        status.camPermission = camPerm.state;

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        const audioTracks = stream.getAudioTracks();
        status.hasAudio = audioTracks.length > 0;
        status.audioEnabled = audioTracks.some(t => t.enabled);

        const videoTracks = stream.getVideoTracks();
        status.hasVideo = videoTracks.length > 0;
        status.videoEnabled = videoTracks.some(t => t.enabled);

        stream.getTracks().forEach(track => track.stop());
      } catch (err) {
        status.error = err.name || err.message;
      }

      console.log("Media Status:", status);
      return status;
    }

    function sendMessage(to, type, payload) {
      const message = { to, type, payload };
      console.log("Sending:", message);
      socket.send(JSON.stringify(message));
    }

    function createPeer() {
      const iceServers = [
        { urls: ["stun:stun.cloudflare.com:3478", "stun:stun.cloudflare.com:53"] },
        {
          urls: [
            "turn:turn.cloudflare.com:3478?transport=udp",
            "turn:turn.cloudflare.com:3478?transport=tcp",
            "turns:turn.cloudflare.com:5349?transport=tcp",
            "turn:turn.cloudflare.com:53?transport=udp",
            "turn:turn.cloudflare.com:80?transport=tcp",
            "turns:turn.cloudflare.com:443?transport=tcp"
          ],
          username: "g06029b93cd518b42c38009ea2d357ed52ef1fba78330a81c283fda35ee71131",
          credential: "98f92c527bea47961e372c68c6e2ae3234def2ea48947ca0fed5c2adf177567b"
        }
      ];

      const pc = new RTCPeerConnection({ iceServers });

      pc.onicecandidate = (event) => {
        if (event.candidate && targetId) {
          sendMessage(targetId, "ice", event.candidate);
        }
      };

      pc.ontrack = (event) => {
        remoteVideo.srcObject = event.streams[0];
        if (isCallAcceptedByCallee || isCallAccepted) {
          remoteVideo.style.display = "block"; // Show remote video only if call accepted
        }
      };

      return pc;
    }

    async function startCall() {
      targetId = document.getElementById("targetId").value.trim();
      if (!targetId) {
        alert("Please enter the target client ID");
        return;
      }

      isCallAccepted = false;
      peer = createPeer();

      // Send offer without adding tracks yet â€” wait for accept
      try {
        const offer = await peer.createOffer();
        await peer.setLocalDescription(offer);
        sendMessage(targetId, "offer", offer);
      } catch (err) {
        console.error("Error starting call:", err);
      }
    }

    socket.addEventListener("open", async () => {
      const mediaStatus = await checkMediaStatus();
      if (mediaStatus.error) {
        console.error("Media error:", mediaStatus.error);
        return;
      }

      localStream = new MediaStream();

      try {
        const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioStream.getAudioTracks().forEach(track => localStream.addTrack(track));
      } catch (err) {
        console.warn("Audio fetch failed:", err);
      }

      try {
        const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoStream.getVideoTracks().forEach(track => localStream.addTrack(track));
      } catch (err) {
        console.warn("Video fetch failed:", err);
      }

      if (localStream.getTracks().length === 0) {
        console.error("No media tracks available. Aborting WebRTC setup.");
        return;
      }

      localVideo.srcObject = localStream;
      // Do NOT create peer or add tracks here for incoming calls,
      // peer will be created on accept for callee
    });

    socket.addEventListener("message", async (event) => {
      const msg = JSON.parse(event.data);
      console.log("Message received:", msg);

      if (msg.type === "init") {
        myId = msg.payload;
        document.getElementById("idOutput").textContent = "My ID is " + myId;
      }

      if (msg.type === "offer") {
        targetId = msg.from;
        incomingOffer = msg.payload;

        callerIdSpan.textContent = targetId;
        incomingCallBanner.style.display = "block";

        // Don't create peer or set remote description yet â€” wait for accept

      }

      if (msg.type === "answer") {
        if (!peer) return;

        try {
          await peer.setRemoteDescription(new RTCSessionDescription(msg.payload));

          if (!isCallAccepted) {
            // Now that callee accepted, add local tracks and show controls
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
            isCallAccepted = true;
            toggleAudioBtn.style.display = "inline-block";
            toggleVideoBtn.style.display = "inline-block";
          }

          // Add queued ICE candidates now
          remoteCandidatesQueue.forEach(async candidate => {
            try {
              await peer.addIceCandidate(candidate);
            } catch (e) {
              console.error("Error adding queued ICE candidate:", e);
            }
          });
          remoteCandidatesQueue = [];
        } catch (err) {
          console.error("Error handling answer:", err);
        }
      }

      if (msg.type === "ice") {
        const candidate = new RTCIceCandidate(msg.payload);
        if (peer && peer.remoteDescription && peer.remoteDescription.type) {
          try {
            await peer.addIceCandidate(candidate);
          } catch (e) {
            console.error("Error adding ICE candidate:", e);
          }
        } else {
          // Remote description not set yet, queue candidate
          remoteCandidatesQueue.push(candidate);
        }
      }

      if (msg.type === "decline") {
        alert("Call was declined by the callee.");
        if (peer) {
          peer.close();
          peer = null;
        }
        isCallAccepted = false;
      }
    });

    acceptCallBtn.onclick = async () => {
      incomingCallBanner.style.display = "none";

      if (!peer) {
        peer = createPeer();
      }

      try {
        await peer.setRemoteDescription(new RTCSessionDescription(incomingOffer));

        // Add local tracks and start streaming only now
        localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

        const answer = await peer.createAnswer();
        await peer.setLocalDescription(answer);
        sendMessage(targetId, "answer", answer);

        isCallAcceptedByCallee = true;

        // Show video controls now
        toggleAudioBtn.style.display = "inline-block";
        toggleVideoBtn.style.display = "inline-block";

        // Show remote video once stream arrives
        // remoteVideo.style.display = "block";  <-- handled on ontrack

      } catch (err) {
        console.error("Error accepting call:", err);
      }
    };

    declineCallBtn.onclick = () => {
      incomingCallBanner.style.display = "none";
      incomingOffer = null;
      if (targetId) {
        sendMessage(targetId, "decline", { reason: "User declined the call." });
      }
      targetId = null;
    };

    // Toggle audio and video buttons functionality
    toggleAudioBtn.onclick = () => {
      if (!localStream) return;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !track.enabled;
        toggleAudioBtn.textContent = `Audio (${track.enabled ? "On" : "Off"})`;
      });
    };

    toggleVideoBtn.onclick = () => {
      if (!localStream) return;
      localStream.getVideoTracks().forEach(track => {
        track.enabled = !track.enabled;
        toggleVideoBtn.textContent = `Video (${track.enabled ? "On" : "Off"})`;
      });
    };
  </script>
</body>
</html>
