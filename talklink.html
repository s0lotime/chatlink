<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chatlink WebRTC Call with Dark Mode & Call Controls</title>
  <style>
    /* Dark mode base */
    body {
      background-color: #121212;
      color: #ddd;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    input, button {
      font-size: 1rem;
      padding: 10px;
      margin: 5px;
      border-radius: 5px;
      border: none;
      outline: none;
    }
    input {
      width: 200px;
    }
    button {
      cursor: pointer;
      background-color: #333;
      color: #eee;
      transition: background-color 0.3s ease;
    }
    button:hover:not(:disabled) {
      background-color: #555;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    video, audio {
      border: 2px solid #444;
      border-radius: 8px;
      margin: 10px;
      background-color: black;
    }
    video {
      width: 40%;
      height: auto;
      vertical-align: middle;
    }
    audio {
      width: 300px;
      margin-top: 10px;
    }
    #equalizer {
      width: 90%;
      height: 100px;
      background-color: #222;
      margin: 20px auto;
      border-radius: 8px;
      display: block;
    }
    #incomingCall {
      margin-top: 20px;
      padding: 15px;
      background-color: #282828;
      border-radius: 10px;
      display: none;
    }
    #incomingCall p {
      font-size: 1.2rem;
      margin-bottom: 10px;
    }
    /* Blinking ring alert */
    @keyframes blink {
      0%, 100% { color: #ff5555; }
      50% { color: #ff0000; }
    }
    #incomingCall p.blink {
      animation: blink 1s infinite;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Chatlink WebRTC Call</h1>
  <h2 id="idOutput">My ID: ...</h2>

  <video id="localVideo" autoplay playsinline muted></video>
  <video id="remoteVideo" autoplay playsinline></video>
  <audio id="remoteAudio" autoplay></audio>

  <br />

  <input id="targetId" placeholder="Target client ID" />
  <button id="startCallBtn">Start Call</button>
  <button id="toggleAudioBtn">Audio (On)</button>
  <button id="toggleVideoBtn">Video (On)</button>
  <button id="hangUpBtn" disabled>Hang Up</button>

  <canvas id="equalizer"></canvas>

  <div id="incomingCall">
    <p class="blink">Incoming call from <span id="callerId"></span></p>
    <button id="acceptCallBtn">Accept</button>
    <button id="declineCallBtn">Decline</button>
  </div>

  <audio id="ringtone" loop>
    <source src="https://actions.google.com/sounds/v1/alarms/phone_alerts_and_rings.ogg" type="audio/ogg">
  </audio>

  <script>
    // Elements
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const remoteAudio = document.getElementById("remoteAudio");
    const targetIdInput = document.getElementById("targetId");
    const startCallBtn = document.getElementById("startCallBtn");
    const toggleAudioBtn = document.getElementById("toggleAudioBtn");
    const toggleVideoBtn = document.getElementById("toggleVideoBtn");
    const hangUpBtn = document.getElementById("hangUpBtn");

    const incomingCallDiv = document.getElementById("incomingCall");
    const callerIdSpan = document.getElementById("callerId");
    const acceptCallBtn = document.getElementById("acceptCallBtn");
    const declineCallBtn = document.getElementById("declineCallBtn");

    const ringtone = document.getElementById("ringtone");

    let socket;
    let peerConnection;
    let localStream;
    let myId;
    let currentCallId = null;
    let audioTrack, videoTrack;

    function log(msg, ...args) {
      console.log("[Chatlink]", msg, ...args);
    }

    // Setup WebSocket connection
    function connectSocket() {
      socket = new WebSocket("wss://chatlink.space/messagerouting/call/connection?room=default");

      socket.addEventListener("open", async () => {
        log("WebSocket connected");
        await setupMedia();
      });

      socket.addEventListener("message", async (event) => {
        const msg = JSON.parse(event.data);
        log("Message received:", msg);

        if (msg.type === "welcome") {
          myId = msg.id;
          document.getElementById("idOutput").textContent = `My ID: ${myId}`;
        }

        if (msg.type === "offer") {
          if (currentCallId) {
            // Already in a call, auto reject or ignore
            log("Received offer while busy. Ignoring...");
            sendMessage(msg.from, "reject", { reason: "busy" });
            return;
          }
          currentCallId = msg.from;
          callerIdSpan.textContent = currentCallId;
          showIncomingCall(true);
          playRingtone(true);

          // Save remote SDP to be used if call accepted
          window.incomingOffer = msg.payload;
        }

        if (msg.type === "answer") {
          if (!peerConnection) return;
          try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.payload));
            log("Remote description set (answer)");
          } catch (err) {
            console.error("Error setting remote description (answer):", err);
          }
        }

        if (msg.type === "ice") {
          if (!peerConnection) return;
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(msg.payload));
            log("ICE candidate added");
          } catch (err) {
            console.error("Error adding ICE candidate:", err);
          }
        }

        if (msg.type === "reject") {
          alert(`Call rejected by ${msg.from}. Reason: ${msg.payload.reason || "No reason"}`);
          endCall();
        }
      });

      socket.addEventListener("close", () => {
        log("WebSocket disconnected");
        endCall();
      });
    }

    // Send message via socket
    function sendMessage(to, type, payload) {
      if (!socket || socket.readyState !== WebSocket.OPEN) return;
      const msg = { to, type, payload };
      log("Sending:", msg);
      socket.send(JSON.stringify(msg));
    }

    // Create silent audio track fallback
    function createSilentAudioTrack() {
      const ctx = new AudioContext();
      const oscillator = ctx.createOscillator();
      const dst = oscillator.connect(ctx.createMediaStreamDestination());
      oscillator.start();
      const track = dst.stream.getAudioTracks()[0];
      return Object.assign(track, { enabled: true });
    }

    // Setup media and peer connection
    async function setupMedia() {
      try {
        const userStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        const audioTracks = userStream.getAudioTracks();
        const videoTracks = userStream.getVideoTracks();

        audioTrack = audioTracks[0] || createSilentAudioTrack();
        videoTrack = videoTracks[0] || null;

        const tracks = [audioTrack];
        if (videoTrack) tracks.push(videoTrack);

        localStream = new MediaStream(tracks);
        localVideo.srcObject = localStream;

        toggleAudioBtn.disabled = audioTracks.length === 0;
        toggleVideoBtn.disabled = videoTracks.length === 0;

        createPeerConnection();

      } catch (err) {
        console.error("Error accessing media devices:", err);
      }
    }

    // Create new RTCPeerConnection
    function createPeerConnection() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      const iceServers = [
        {
          urls: [
            "stun:stun.cloudflare.com:3478",
            "stun:stun.cloudflare.com:53"
          ]
        },
        {
          urls: [
            "turn:turn.cloudflare.com:3478?transport=udp",
            "turn:turn.cloudflare.com:3478?transport=tcp",
            "turns:turn.cloudflare.com:5349?transport=tcp",
            "turn:turn.cloudflare.com:53?transport=udp",
            "turn:turn.cloudflare.com:80?transport=tcp",
            "turns:turn.cloudflare.com:443?transport=tcp"
          ],
          username: "g06029b93cd518b42c38009ea2d357ed52ef1fba78330a81c283fda35ee71131",
          credential: "98f92c527bea47961e372c68c6e2ae3234def2ea48947ca0fed5c2adf177567b"
        }
      ];

      peerConnection = new RTCPeerConnection({ iceServers });

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && currentCallId) {
          sendMessage(currentCallId, "ice", event.candidate);
        }
      };

      peerConnection.ontrack = (event) => {
        // Separate remote audio and video tracks
        // If the track kind is video, attach to remoteVideo
        // If audio, attach to remoteAudio

        if (event.track.kind === "video") {
          if (!remoteVideo.srcObject) {
            remoteVideo.srcObject = new MediaStream();
          }
          remoteVideo.srcObject.addTrack(event.track);
        } else if (event.track.kind === "audio") {
          if (!remoteAudio.srcObject) {
            remoteAudio.srcObject = new MediaStream();
          }
          remoteAudio.srcObject.addTrack(event.track);
        }
      };

      // Add local tracks to peer connection
      if (audioTrack) peerConnection.addTrack(audioTrack, localStream);
      if (videoTrack) peerConnection.addTrack(videoTrack, localStream);
    }

    // Call flow controls

    // Start outgoing call
    async function startCall() {
      const targetId = targetIdInput.value.trim();
      if (!targetId) {
        alert("Please enter the target client ID");
        return;
      }
      if (currentCallId) {
        alert("You are already in a call.");
        return;
      }
      currentCallId = targetId;
      createPeerConnection();

      try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        sendMessage(targetId, "offer", offer);
        startCallBtn.disabled = true;
        hangUpBtn.disabled = false;
        toggleAudioBtn.disabled = false;
        toggleVideoBtn.disabled = false;
      } catch (err) {
        console.error("Error starting call:", err);
        currentCallId = null;
      }
    }

    // Accept incoming call
    async function acceptCall() {
      showIncomingCall(false);
      playRingtone(false);

      createPeerConnection();

      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(window.incomingOffer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        sendMessage(currentCallId, "answer", answer);

        startCallBtn.disabled = true;
        hangUpBtn.disabled = false;
        toggleAudioBtn.disabled = false;
        toggleVideoBtn.disabled = false;
      } catch (err) {
        console.error("Error accepting call:", err);
        endCall();
      }
    }

    // Decline incoming call
    function declineCall() {
      if (!currentCallId) return;
      sendMessage(currentCallId, "reject", { reason: "declined" });
      currentCallId = null;
      showIncomingCall(false);
      playRingtone(false);
    }

    // End call and cleanup
    function endCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      currentCallId = null;
      remoteVideo.srcObject = null;
      remoteAudio.srcObject = null;
      startCallBtn.disabled = false;
      hangUpBtn.disabled = true;
      toggleAudioBtn.disabled = true;
      toggleVideoBtn.disabled = true;
      toggleAudioBtn.textContent = "Audio (On)";
      toggleVideoBtn.textContent = "Video (On)";
    }

    // Show/hide incoming call UI
    function showIncomingCall(show) {
      incomingCallDiv.style.display = show ? "block" : "none";
      startCallBtn.disabled = show;
      hangUpBtn.disabled = show;
      toggleAudioBtn.disabled = show;
      toggleVideoBtn.disabled = show;
    }

    // Play or stop ringtone
    function playRingtone(play) {
      if (play) {
        ringtone.play().catch(() => {
          // Autoplay might be blocked
        });
      } else {
        ringtone.pause();
        ringtone.currentTime = 0;
      }
    }

    // Toggle local audio
    function toggleAudio() {
      if (!audioTrack) return;
      audioTrack.enabled = !audioTrack.enabled;
      toggleAudioBtn.textContent = `Audio (${audioTrack.enabled ? "On" : "Off"})`;
    }

    // Toggle local video
    function toggleVideo() {
      if (!videoTrack) return;
      videoTrack.enabled = !videoTrack.enabled;
      toggleVideoBtn.textContent = `Video (${videoTrack.enabled ? "On" : "Off"})`;
    }

    // Hang up current call
    function hangUp() {
      if (!currentCallId) return;
      sendMessage(currentCallId, "reject", { reason: "hangup" });
      endCall();
    }

    // Event listeners
    startCallBtn.addEventListener("click", startCall);
    acceptCallBtn.addEventListener("click", acceptCall);
    declineCallBtn.addEventListener("click", declineCall);
    toggleAudioBtn.addEventListener("click", toggleAudio);
    toggleVideoBtn.addEventListener("click", toggleVideo);
    hangUpBtn.addEventListener("click", hangUp);

    // Initialize
    connectSocket();

  </script>
</body>
</html>
