<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebRTC Screen Share</title>
</head>
<body>
  <h1>Screen Sharing via Room ID</h1>
  <input type="text" id="roomId" placeholder="Enter Room ID" />
  <button id="startCall">Join Room</button>
  <button id="shareScreen">Start Screen Share</button>

  <div>
    <h2>Your Screen</h2>
    <video id="localVideo" autoplay muted playsinline></video>
  </div>
  <div>
    <h2>Remote Screen</h2>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <script>
    let localConnection;
    let localStream;
    let remoteStream = new MediaStream();
    let ws;
    let role;
    let iceServers = [];
    const wsUrl = 'wss://chatlink.space/messagerouting/webrtc/signal';
    let candidateQueue = [];

    document.getElementById('startCall').addEventListener('click', startCall);
    document.getElementById('shareScreen').addEventListener('click', startScreenShare);

    async function startCall() {
      const roomId = document.getElementById('roomId').value.trim();
      if (!roomId) return alert('Enter Room ID');

      try {
        const response = await fetch('/messagerouting/webrtc/ice');
        const data = await response.json();
        if (!Array.isArray(data.iceServers)) throw new Error("Invalid ICE servers");
        iceServers = data.iceServers;
      } catch (err) {
        console.error('Failed to fetch ICE servers:', err);
        return;
      }

      ws = new WebSocket(`${wsUrl}?id=${roomId}`);

      ws.onopen = () => console.log('WebSocket connected');
      ws.onerror = err => console.error('WebSocket error:', err);

      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        if (message.error) return alert(message.error);

        if (message.role) {
          role = message.role;
          console.log('Assigned role:', role);
          await setupPeerConnection();
          if (role === 'offerer') await createAndSendOffer();
        }

        if ((message.type === 'offer' || message.type === 'answer' || message.type === 'candidate') && !localConnection) {
          await setupPeerConnection();
        }

        if (message.type === 'offer') {
          await localConnection.setRemoteDescription(new RTCSessionDescription(message));
          const answer = await localConnection.createAnswer();
          await localConnection.setLocalDescription(answer);
          sendMessage({ type: 'answer', sdp: answer.sdp });
        } else if (message.type === 'answer') {
          await localConnection.setRemoteDescription(new RTCSessionDescription(message));
        } else if (message.type === 'candidate') {
          const candidate = new RTCIceCandidate(message.candidate);
          await localConnection.addIceCandidate(candidate);
        }
      };
    }

    async function setupPeerConnection() {
      const localVideo = document.getElementById('localVideo');
      const remoteVideo = document.getElementById('remoteVideo');

      localConnection = new RTCPeerConnection({ iceServers });

      localConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('Generated ICE candidate:', event.candidate);
          if (localConnection.remoteDescription) {
            sendMessage({ type: 'candidate', candidate: event.candidate });
          } else {
            candidateQueue.push(event.candidate);
          }
        }
      };

      localConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
        remoteVideo.srcObject = remoteStream;
      };

      flushCandidateQueue();
    }

    async function startScreenShare() {
      try {
        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
        localStream = screenStream;

        document.getElementById('localVideo').srcObject = screenStream;

        const sender = localConnection.getSenders().find(s => s.track?.kind === 'video');
        const screenTrack = screenStream.getVideoTracks()[0];

        if (sender) {
          sender.replaceTrack(screenTrack);
        } else {
          screenStream.getTracks().forEach(track => localConnection.addTrack(track, screenStream));
        }

        screenTrack.onended = async () => {
          console.log('Screen sharing ended');
        };
      } catch (err) {
        console.error('Screen sharing failed:', err);
      }
    }

    async function createAndSendOffer() {
      const offer = await localConnection.createOffer();
      await localConnection.setLocalDescription(offer);
      sendMessage({ type: 'offer', sdp: offer.sdp });
    }

    function sendMessage(message) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
      }
    }

    function flushCandidateQueue() {
      if (candidateQueue.length && localConnection.remoteDescription) {
        candidateQueue.forEach(candidate => {
          sendMessage({ type: 'candidate', candidate });
        });
        candidateQueue = [];
      }
    }
  </script>
</body>
</html>
