<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebRTC with Role Assignment</title>
</head>
<body>
  <h1>WebRTC Call via Room ID</h1>
  <input type="text" id="roomId" placeholder="Enter Room ID" />
  <button id="startCall">Join Room</button>

  <div>
    <h2>Your Video Feed (Local)</h2>
    <video id="localVideo" autoplay muted></video>
  </div>
  <div>
    <h2>Remote Video Feed</h2>
    <video id="remoteVideo" autoplay></video>
  </div>

  <script>
    let localConnection;
    let remoteStream = new MediaStream();
    let localStream;
    let ws;
    let role;
    let iceServers = [];
    let candidateQueue = []; // Queue for ICE candidates

    const wsUrl = 'wss://chatlink.space/messagerouting/webrtc/signal';

    document.getElementById('startCall').addEventListener('click', startCall);

    async function startCall() {
      const roomId = document.getElementById('roomId').value.trim();
      if (!roomId) {
        alert('Please enter a Room ID');
        return;
      }

      // Fetch ICE servers
      try {
        const response = await fetch('/messagerouting/webrtc/ice');
        const data = await response.json();
        if (!Array.isArray(data.iceServers)) throw new Error("Invalid ICE format");
        iceServers = data.iceServers;
      } catch (err) {
        console.error('Failed to fetch ICE servers:', err);
        return;
      }

      // Open WebSocket for signaling
      ws = new WebSocket(`${wsUrl}?id=${roomId}`);

      ws.onopen = () => console.log('WebSocket connected');
      ws.onerror = (err) => console.error('WebSocket error:', err);

      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);

        if (message.error) {
          alert(message.error);
          return;
        }

        if (message.role) {
          role = message.role;
          console.log("Assigned role:", role);
          await setupPeerConnection();
          if (role === 'offerer') await createAndSendOffer();
        }

        // Ensure peer connection is ready before handling offer/answer/candidate
        if ((message.type === 'offer' || message.type === 'answer' || message.type === 'candidate') && !localConnection) {
          await setupPeerConnection();
        }

        if (message.type === 'offer') {
          await localConnection.setRemoteDescription(new RTCSessionDescription(message));
          const answer = await localConnection.createAnswer();
          await localConnection.setLocalDescription(answer);
          sendMessage({ type: 'answer', sdp: answer.sdp });
        } else if (message.type === 'answer') {
          await localConnection.setRemoteDescription(new RTCSessionDescription(message));
        } else if (message.type === 'candidate') {
          const candidate = new RTCIceCandidate(message.candidate);
          await localConnection.addIceCandidate(candidate);
        }
      };
    }

    async function setupPeerConnection() {
      // Get media (local stream)
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

      const localVideo = document.getElementById('localVideo');
      localVideo.srcObject = localStream; // Attach local stream to local video element

      // Create a remote video element
      const remoteVideo = document.getElementById('remoteVideo');
      remoteVideo.srcObject = remoteStream; // Attach remote stream to remote video element

      localConnection = new RTCPeerConnection({ iceServers });

      // Add tracks to the peer connection from local stream
      localStream.getTracks().forEach(track => localConnection.addTrack(track, localStream));

      // ICE candidate handling
      localConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('Candidate generated:', event.candidate);
          if (localConnection.remoteDescription) {
            // If remote description is set, send the candidate immediately
            sendMessage({ type: 'candidate', candidate: event.candidate });
          } else {
            // If remote description is not set, queue the candidate
            candidateQueue.push(event.candidate);
          }
        }
      };

      // Handle incoming tracks from the remote peer
      localConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track); // Add remote tracks to the remote stream
        });
      };

      // Once remote description is set, flush candidate queue
      flushCandidateQueue();
    }

    async function createAndSendOffer() {
      const offer = await localConnection.createOffer();
      await localConnection.setLocalDescription(offer);
      console.log('Offer sent:', offer);
      sendMessage({ type: 'offer', sdp: offer.sdp });

      // After sending the offer, flush candidate queue (send candidates to the answerer)
      flushCandidateQueue();
    }

    function sendMessage(message) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
      }
    }

    // Once remote description is set, send any queued candidates
    function flushCandidateQueue() {
      if (candidateQueue.length > 0 && localConnection.remoteDescription) {
        candidateQueue.forEach(candidate => {
          console.log('Sending queued candidate:', candidate);
          sendMessage({ type: 'candidate', candidate: candidate });
        });
        candidateQueue = []; // Clear the queue after sending
      }
    }
  </script>
</body>
</html>
