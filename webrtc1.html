<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebRTC with Role Assignment</title>
</head>
<body>
  <h1>WebRTC Call via Room ID</h1>
  <input type="text" id="roomId" placeholder="Enter Room ID" />
  <button id="startCall">Join Room</button>

  <script>
    let localConnection;
    let remoteStream = new MediaStream();
    let localStream;
    let ws;
    let role;
    let iceServers = [];

    const wsUrl = 'wss://chatlink.space/messagerouting/webrtc/signal';

    document.getElementById('startCall').addEventListener('click', startCall);

    async function startCall() {
      const roomId = document.getElementById('roomId').value.trim();
      if (!roomId) {
        alert('Please enter a Room ID');
        return;
      }

      // Fetch ICE servers
      try {
        const response = await fetch('/messagerouting/webrtc/ice');
        const data = await response.json();
        if (!Array.isArray(data.iceServers)) throw new Error("Invalid ICE format");
        iceServers = data.iceServers;
      } catch (err) {
        console.error('Failed to fetch ICE servers:', err);
        return;
      }

      // Open WebSocket for signaling
      ws = new WebSocket(`${wsUrl}?id=${roomId}`);

      ws.onopen = () => console.log('WebSocket connected');
      ws.onerror = (err) => console.error('WebSocket error:', err);

      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);

        if (message.error) {
          alert(message.error);
          return;
        }

        if (message.role) {
          role = message.role;
          console.log("Assigned role:", role);
          await setupPeerConnection();
          if (role === 'offerer') await createAndSendOffer();
        }

        // Ensure peer connection is ready before processing messages
        if ((message.type === 'offer' || message.type === 'answer' || message.type === 'candidate') && !localConnection) {
          await setupPeerConnection();
        }

        if (message.type === 'offer') {
          await localConnection.setRemoteDescription(new RTCSessionDescription(message));
          const answer = await localConnection.createAnswer();
          await localConnection.setLocalDescription(answer);
          sendMessage({ type: 'answer', sdp: answer.sdp });
        } else if (message.type === 'answer') {
          await localConnection.setRemoteDescription(new RTCSessionDescription(message));
        } else if (message.type === 'candidate') {
          const candidate = new RTCIceCandidate(message.candidate);
          await localConnection.addIceCandidate(candidate);
        }
      };
    }

    async function setupPeerConnection() {
      // Get media
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

      const localVideo = document.createElement('video');
      localVideo.srcObject = localStream;
      localVideo.autoplay = true;
      localVideo.muted = true;
      document.body.appendChild(localVideo);

      const remoteVideo = document.createElement('video');
      remoteVideo.srcObject = remoteStream;
      remoteVideo.autoplay = true;
      document.body.appendChild(remoteVideo);

      localConnection = new RTCPeerConnection({ iceServers });

      localStream.getTracks().forEach(track => localConnection.addTrack(track, localStream));

      localConnection.onicecandidate = (event) => {
        if (event.candidate) {
          sendMessage({ type: 'candidate', candidate: event.candidate });
        }
      };

      // Fix for the offerer not seeing the other person's video
      localConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
      };
    }

    async function createAndSendOffer() {
      const offer = await localConnection.createOffer();
      await localConnection.setLocalDescription(offer);
      sendMessage({ type: 'offer', sdp: offer.sdp });
    }

    function sendMessage(message) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
      }
    }
  </script>
</body>
</html>
